# Application Architecture

## High-Level Overview

This is a full-stack web application demonstrating modern development practices with:
- **Frontend**: Qwik (JavaScript framework optimized for speed)
- **Backend**: Payload CMS with GraphQL API
- **Authentication**: Zitadel (OAuth2/OIDC)
- **Real-time Chat**: Matrix with matrix-js-sdk
- **Database**: PostgreSQL

---

## Frontend Architecture (Qwik)

### Why Qwik?

Qwik is an advanced frontend framework that:
- **Resumes instead of Hydrates**: Ships minimal JavaScript
- **Lazy Loads on Demand**: Components load only when needed
- **Fast by Default**: Extremely fast page loads and interactions
- **Type Safe**: Full TypeScript support

### Frontend Components Structure

```
src/
├── routes/
│   ├── index.tsx              # Home page
│   ├── products/
│   │   ├── index.tsx          # Products listing
│   │   └── [id].tsx           # Product detail
│   ├── chat/
│   │   └── index.tsx          # Chat interface
│   └── auth/
│       └── callback.tsx       # OAuth callback handler
├── components/
│   ├── header/               # Navigation header
│   ├── product-card/         # Product display card
│   └── chat-window/          # Chat interface
├── lib/
│   ├── env.ts               # Environment variables
│   ├── auth.ts              # Authentication service
│   ├── graphql-client.ts    # GraphQL queries
│   └── matrix-client.ts     # Matrix chat integration
└── global.css               # Global styles
```

### State Management

The application uses:
- **Qwik Signals** (`useSignal$`): Reactive state management
- **Local Storage**: Persistent authentication tokens
- **Component Props**: Data passing between components

### Authentication Flow

```
User clicks Login
    ↓
initiate Zitadel login
    ↓
Redirect to Zitadel
    ↓
User enters credentials
    ↓
Redirect to /auth/callback with code
    ↓
Exchange code for tokens
    ↓
Store tokens in localStorage
    ↓
Redirect to /products
```

### Styling

- **CSS Modules**: Scoped component styles
- **BEM Convention**: Block, Element, Modifier naming
- **Responsive Design**: Mobile-first approach
- **Media Queries**: Breakpoints at 768px

---

## Backend Architecture (Payload CMS)

### Why Payload?

Payload is a modern headless CMS that:
- **Headless Architecture**: REST and GraphQL APIs
- **Type-Safe**: TypeScript-first
- **Customizable**: Built with developer experience in mind
- **Database Agnostic**: Works with MongoDB, PostgreSQL, SQLite

### Backend Structure

```
payload-cms/
├── src/
│   ├── server.ts            # Express server setup
│   ├── payload.config.ts    # Payload configuration
│   ├── collections/
│   │   ├── Users.ts         # User collection
│   │   └── Products.ts      # Product collection
│   ├── utils/
│   │   └── zitadel.ts       # Zitadel integration
│   └── endpoints/
│       └── auth.ts          # Authentication endpoints
└── package.json
```

### Collections (Data Models)

#### Users Collection
- Email (unique, indexed)
- Name
- Role (admin, user)
- Zitadel ID (linked to external auth)
- Zitadel Profile (JSON metadata)
- Active status

#### Products Collection
- Title
- Description (rich text)
- Base Price
- Image (file upload)
- Variants (array of variant objects)
  - SKU (unique, indexed)
  - Name
  - Color
  - Size
  - Price
  - Stock quantity
  - Availability status
- Category
- Tags
- Featured flag

### API Endpoints

#### REST Endpoints (Auto-generated by Payload)
- `GET /api/products` - List products
- `GET /api/products/:id` - Get single product
- `GET /api/users` - List users (admin only)
- `POST /api/auth` - Authenticate

#### GraphQL Endpoints
- `POST /graphql` - GraphQL queries and mutations

#### Custom Endpoints
- `GET /api/auth/zitadel-login` - Initiate OAuth flow
- `POST /api/auth/zitadel-callback` - Handle OAuth callback
- `POST /api/auth/logout` - Logout user

---

## Authentication Architecture

### Zitadel Integration

Zitadel is an identity and access management platform that:
- Handles user authentication
- Manages user profiles
- Provides OAuth2/OIDC endpoints
- Integrates with Payload for user management

### OAuth2/OIDC Flow

```
┌─────────────────────────────────────────────────────────────┐
│ 1. User clicks "Login with Zitadel"                         │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ 2. Frontend: GET /api/auth/zitadel-login                    │
│    Backend generates authorization URL with:                │
│    - client_id                                              │
│    - redirect_uri (callback URL)                            │
│    - scope (openid, profile, email)                         │
│    - state (CSRF protection)                                │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ 3. Frontend: Redirect to Zitadel authorization endpoint    │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ 4. User: Enters credentials at Zitadel                      │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ 5. Zitadel: Redirects to /auth/callback with code           │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ 6. Frontend: Extracts code from URL                         │
│    POST /api/auth/zitadel-callback with code               │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ 7. Backend: Exchanges code for tokens                       │
│    POST to Zitadel token endpoint                           │
│    Returns: access_token, id_token, refresh_token          │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ 8. Backend: Fetches user info from Zitadel                 │
│    GET to /oauth/v2/userinfo with access_token            │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ 9. Frontend: Stores tokens in localStorage                  │
│    Updates auth state (isAuthenticated = true)             │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ 10. Frontend: Redirects to /products                        │
└─────────────────────────────────────────────────────────────┘
```

### Token Storage & Refresh

- **Access Token**: Stored in localStorage
- **Refresh Token**: Stored in localStorage
- **Token Expiration**: Checked before API calls
- **Auto Refresh**: Tokens refreshed before expiration

---

## Chat Architecture (Matrix)

### Why Matrix?

Matrix is an open standard for decentralized communication:
- **Decentralized**: No single point of failure
- **Real-time**: Low latency messaging
- **Interoperable**: Works across different servers
- **Secure**: End-to-end encryption support

### Matrix Integration

The application uses `matrix-js-sdk` to:
1. Connect to Matrix homeserver
2. Authenticate user
3. Join/create chat rooms
4. Send/receive messages
5. Sync message history

### Chat Flow

```
┌─────────────────────────────────────────────────────────────┐
│ 1. User navigates to /chat (must be authenticated)          │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ 2. Frontend: Initialize MatrixChatClient                    │
│    Connects to Matrix homeserver                            │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ 3. Frontend: Join "general" room                            │
│    POST /_matrix/client/r0/join/general                    │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ 4. Frontend: Load message history                           │
│    GET /_matrix/client/r0/rooms/{roomId}/messages          │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ 5. Frontend: Display messages in chat window                │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ 6. User types and sends message                             │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ 7. Frontend: POST message to Matrix                         │
│    POST /_matrix/client/r0/rooms/{roomId}/send/m.room...  │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ 8. Frontend: Reload messages                                │
│    Update chat window display                               │
└─────────────────────────────────────────────────────────────┘
```

### Matrix Room Structure

```
general (public chat room)
├── Message 1 (user 1)
├── Message 2 (user 2)
├── Message 3 (user 1)
└── ...
```

---

## Database Architecture

### PostgreSQL Schema

#### Users Table
```sql
CREATE TABLE users (
  id VARCHAR PRIMARY KEY,
  email VARCHAR UNIQUE NOT NULL,
  name VARCHAR NOT NULL,
  role VARCHAR DEFAULT 'user',
  zitadel_id VARCHAR UNIQUE,
  zitadel_profile JSONB,
  active BOOLEAN DEFAULT true,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

#### Products Table
```sql
CREATE TABLE products (
  id VARCHAR PRIMARY KEY,
  title VARCHAR NOT NULL,
  description TEXT NOT NULL,
  base_price NUMERIC NOT NULL,
  category VARCHAR,
  featured BOOLEAN DEFAULT false,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

#### Variants Array (within Products)
```sql
variants: [
  {
    sku: VARCHAR UNIQUE,
    name: VARCHAR,
    color: VARCHAR,
    size: VARCHAR,
    price: NUMERIC,
    stock: INTEGER,
    isAvailable: BOOLEAN
  }
]
```

### Indexes

```sql
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_zitadel_id ON users(zitadel_id);
CREATE INDEX idx_products_featured ON products(featured);
CREATE INDEX idx_products_category ON products(category);
CREATE INDEX idx_variants_sku ON products USING GIN (variants);
```

---

## Data Flow Diagrams

### Product Loading Flow

```
User visits /products
    ↓
useEffect$ hook triggers
    ↓
graphqlClient.query(getProducts)
    ↓
POST to VITE_GRAPHQL_ENDPOINT
    ↓
Payload: Execute GraphQL query
    ↓
PostgreSQL: Fetch products
    ↓
Return products array
    ↓
useSignal update: products.value = data
    ↓
Component re-renders with products
    ↓
Display ProductCard components
```

### Message Sending Flow

```
User types message and clicks Send
    ↓
sendMessage$ function executes
    ↓
MatrixChatClient.sendMessage(text)
    ↓
POST to Matrix homeserver
    ↓
/_matrix/client/r0/rooms/{roomId}/send/m.room.message
    ↓
Matrix server stores message
    ↓
loadMessages() reloads history
    ↓
notifyListeners() updates subscribers
    ↓
messages.value = updated array
    ↓
Component re-renders chat window
    ↓
New message appears in UI
```

---

## Scalability Considerations

### Frontend
- Service Worker caching for offline support
- Lazy loading of routes
- Image optimization
- Code splitting by Qwik

### Backend
- PostgreSQL connection pooling
- GraphQL query optimization
- Caching with Redis (optional)
- Horizontal scaling with load balancer

### Database
- Indexing on frequently queried fields
- Query optimization
- Connection pooling
- Regular backups

### Chat
- Matrix federation for distributed chat
- Message pagination
- Room state caching

---

## Security Architecture

### Authentication Layer
- OAuth2/OIDC with Zitadel
- Secure token storage
- Token refresh mechanism
- CSRF protection with state parameter

### API Layer
- CORS configuration
- Request validation
- Role-based access control (RBAC)
- Token verification on each request

### Database Layer
- Parameterized queries (SQL injection prevention)
- Password hashing (for any local auth)
- Encryption at rest (optional)

### Transport Layer
- HTTPS enforcement
- Secure cookies (HttpOnly, Secure flags)
- Content Security Policy (CSP) headers

---

## Deployment Architecture

### Development
```
Local Machine
├── Payload CMS (port 3001)
├── Qwik Frontend (port 5173)
└── PostgreSQL (port 5432)
```

### Production
```
Cloud Infrastructure
├── Payload CMS (Heroku/Vercel/AWS)
├── Qwik Frontend (Netlify/Vercel/AWS S3 + CloudFront)
├── PostgreSQL (AWS RDS/Google Cloud SQL)
└── Matrix Server (Self-hosted/Managed Service)
```

---

## Performance Metrics

### Core Web Vitals Targets
- **LCP** (Largest Contentful Paint): < 2.5s
- **FID** (First Input Delay): < 100ms
- **CLS** (Cumulative Layout Shift): < 0.1

### Optimization Strategies
- Image optimization and lazy loading
- JavaScript bundling and code splitting
- CSS minification
- Service worker caching
- CDN for static assets

---

## Error Handling

### Frontend Error Handling
- Try-catch blocks in async operations
- Error state signals
- User-friendly error messages
- Error logging to console

### Backend Error Handling
- Request validation
- Proper HTTP status codes
- Detailed error responses
- Server-side logging

### Network Error Handling
- Retry logic for failed requests
- Timeout handling
- Offline detection (PWA)
- Graceful degradation

---

## Integration Points

### Frontend ↔ Backend
```
GraphQL requests: POST /graphql
REST endpoints: GET/POST /api/*
Authentication: OAuth2/OIDC callback
```

### Backend ↔ Zitadel
```
OAuth endpoints
User info endpoint
Token validation
```

### Frontend ↔ Matrix
```
Matrix client library (matrix-js-sdk)
Matrix REST API (_matrix/client/r0/*)
```

---

## Future Enhancements

1. **Shopping Cart**: Persistent cart with local storage
2. **Payment Integration**: Stripe or other payment gateway
3. **Order Management**: Order tracking and history
4. **Admin Dashboard**: Advanced CMS management
5. **Search & Filters**: Product search and filtering
6. **Notifications**: Real-time notifications with Matrix
7. **User Profiles**: Extended user information
8. **Reviews**: Product reviews and ratings
9. **Email Notifications**: Order and chat notifications
10. **Analytics**: Usage tracking and insights
